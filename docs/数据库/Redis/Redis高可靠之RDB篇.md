# Redis高可靠之RDB篇
使用AOF日志其实还是有风险的：AOF操作日志太多的话，Redis恢复很慢，影响使用。
使用**内存快照**可以实现快速恢复。

Redis会将内存中某一个时刻的状态，以文件形式记录到磁盘中，这就是快照文件，即RDB文件。
这样宕机，RDB文件也不会丢失。

    和AOF相比，RDB保存的是数据，而不是操作，所以可以快速恢复。

两个问题：
1. 对哪些数据做快照？
2. 做快照的过程中，数据被修改了怎么办？

## 一. 全量快照
Redis执行全量快照，当全量数据很多，RDB文件很大，写入磁盘会很耗时。  
解决方案是用子进程，防止阻塞主进程。  
Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave。

    save：在主线程中执行，会导致阻塞；
    bgsave：创建一个子进程，专门用于写入RDB文件，这也是 Redis RDB 文件生成的默认配置。

## 二. 快照时数据能修改吗?
做快照时当然希望数据不被修改，否则会破坏数据的完整性（比如做一次快照要20s，
结果在第5s，某个还没做快照的数据被修改了）；但是数据不能被修改就会影响业务，同样无法接受。  

借助操作系统提供的**写时复制技术**（Copy-On-Write, COW），
可实现在执行快照的同时，正常处理写操作。

1. bgsave子进程是由主线程fork生成，可共享主线程的所有内存数据。
bgsave子进程读取主线程的内存数据，写入RDB文件。
2. 如果主线程对这些数据也都是读操作，那么父子进程互不影响；
3. 如果主线程要修改一块数据，那么这块数据就会被复制一份，生成该数据的副本（键值对 C’）。然后主线程在这个数据副本上进行修改。
4. 同时bgsave子进程可以继续把原来的数据（键值对 C）写入RDB文件。 

整个过程可由下图表示

![](Redis图/写时复制机制保证快照期间数据可修改.jpeg)

## 三. 做快照的频次问题
我们希望快照间隔越短越好，这样宕机了丢失的数据也不会太多；但会频次太高会带来
性能问题。
1. 写磁盘时，多个快照竞争有限的磁盘带宽。
2. fork这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。频繁做快照会阻塞主进程。

那怎么解决呢？  

Redis4.0中提出了一个混合使用AOF日志和内存快照的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用AOF日志记录这期间的所有命令操作。  

这样一来，快照不用很频繁地执行，这就避免了频繁fork。AOF日志也只用记录两次快照间的操作，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。

如下图所示，T1 和 T2 时刻的修改，用 AOF 日志记录，等到第二次做全量快照时，就可以清空 AOF 日志，因为此时的修改都已经记录到快照中了，恢复时就不再用日志了。

![img.png](Redis图/AOF和RDB混合使用.png)